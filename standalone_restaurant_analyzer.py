#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Áç®Á´ãÁâàÂàÜÂ∫óË©ïÂÉπÊü•Ë©¢Á≥ªÁµ± - Python GUI Â∑•ÂÖ∑
ÂÆåÂÖ®Áç®Á´ãÈÅãË°åÔºå‰∏ç‰æùË≥¥ Node.js ÂæåÁ´Ø

ÂäüËÉΩÁâπËâ≤:
- ÂÆåÂÖ®Áç®Á´ãÁöÑ Python ÂØ¶Áèæ
- ÂÖßÂª∫Á∂≤È†ÅÁà¨ÂèñÂäüËÉΩÔºàSeleniumÔºâ
- Â§öÁæ§ÁµÑ Telegram ÈÄöÁü•
- ÈÖçÁΩÆË®òÊÜ∂ÂäüËÉΩ
- ÊîØÊè¥ Google Maps„ÄÅUberEats„ÄÅFoodpanda

‰ΩúËÄÖ: Claude Code
ÁâàÊú¨: 2.0 (Áç®Á´ãÁâà)
"""

import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext
import requests
import json
import threading
import os
import time
import re
from datetime import datetime
import webbrowser
from urllib.parse import urlparse, parse_qs
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, NoSuchElementException
import subprocess
import sys
import uuid

class WebScraper:
    """Á∂≤È†ÅÁà¨ÂèñÂô®"""
    
    def __init__(self):
        self.driver = None
        
    def setup_driver(self):
        """Ë®≠ÁΩÆ Chrome WebDriver"""
        try:
            chrome_options = Options()
            chrome_options.add_argument('--headless')  # ÁÑ°È†≠Ê®°Âºè
            chrome_options.add_argument('--no-sandbox')
            chrome_options.add_argument('--disable-dev-shm-usage')
            chrome_options.add_argument('--disable-gpu')
            chrome_options.add_argument('--window-size=1920,1080')
            chrome_options.add_argument('--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36')
            
            # ‰øÆÂæ©WebDriverË°ùÁ™ÅÂïèÈ°å
            import tempfile
            import uuid
            temp_dir = tempfile.gettempdir()
            unique_dir = os.path.join(temp_dir, f"chrome_user_data_{uuid.uuid4().hex[:8]}")
            chrome_options.add_argument(f'--user-data-dir={unique_dir}')
            
            # Á¶ÅÁî®Ëá™ÂãïÂåñÊ™¢Ê∏¨
            chrome_options.add_argument('--disable-blink-features=AutomationControlled')
            chrome_options.add_experimental_option("excludeSwitches", ["enable-automation"])
            chrome_options.add_experimental_option('useAutomationExtension', False)
            
            self.driver = webdriver.Chrome(options=chrome_options)
            self.driver.execute_script("Object.defineProperty(navigator, 'webdriver', {get: () => undefined})")
            self.driver.set_page_load_timeout(60)
            return True
            
        except Exception as e:
            print(f"‚ùå WebDriver Ë®≠ÁΩÆÂ§±Êïó: {e}")
            return False
    
    def close_driver(self):
        """ÈóúÈñâ WebDriver"""
        if self.driver:
            try:
                self.driver.quit()
            except:
                pass
    
    def scrape_google_maps(self, url):
        """Áà¨Âèñ Google Maps Ë©ïÂÉπ"""
        try:
            if not self.driver:
                if not self.setup_driver():
                    raise Exception("WebDriver ÂàùÂßãÂåñÂ§±Êïó")
            
            print(f"üó∫Ô∏è Ê≠£Âú®ÂàÜÊûê Google Maps: {url[:50]}...")
            self.driver.get(url)
            time.sleep(5)
            
            result = {
                'success': False,
                'platform': 'google',
                'storeName': None,
                'rating': None,
                'reviewCount': None,
                'address': None,
                'error': None
            }
            
            try:
                # Â∫óÂêç
                name_selectors = [
                    'h1[data-attrid="title"]',
                    'h1.DUwDvf',
                    'h1.x3AX1-LfntMc-header-title-title',
                    'h1'
                ]
                
                for selector in name_selectors:
                    try:
                        name_element = self.driver.find_element(By.CSS_SELECTOR, selector)
                        result['storeName'] = name_element.text.strip()
                        break
                    except:
                        continue
                
                # Ë©ïÂàÜ
                rating_selectors = [
                    'span.ceNzKf',
                    'div[data-value]',
                    'span[aria-hidden="true"]'
                ]
                
                for selector in rating_selectors:
                    try:
                        rating_elements = self.driver.find_elements(By.CSS_SELECTOR, selector)
                        for element in rating_elements:
                            text = element.text.strip()
                            if re.match(r'^\d+\.?\d*$', text):
                                rating = float(text)
                                if 0 <= rating <= 5:
                                    result['rating'] = rating
                                    break
                        if result['rating']:
                            break
                    except:
                        continue
                
                # Ë©ïË´ñÊï∏
                review_selectors = [
                    'span.F7nice',
                    'button[data-value="Sort"]',
                    'span[aria-label*="ÂâáË©ïË´ñ"]'
                ]
                
                for selector in review_selectors:
                    try:
                        review_elements = self.driver.find_elements(By.CSS_SELECTOR, selector)
                        for element in review_elements:
                            text = element.text.strip()
                            # ÂåπÈÖçÊï∏Â≠óÔºàÂåÖÂê´ÈÄóËôüÔºâ
                            match = re.search(r'([\d,]+)', text)
                            if match:
                                count_text = match.group(1).replace(',', '')
                                if count_text.isdigit():
                                    result['reviewCount'] = int(count_text)
                                    break
                        if result['reviewCount']:
                            break
                    except:
                        continue
                
                # Âú∞ÂùÄ
                try:
                    address_element = self.driver.find_element(By.CSS_SELECTOR, '[data-item-id="address"]')
                    result['address'] = address_element.text.strip()
                except:
                    pass
                
                if result['storeName'] or result['rating']:
                    result['success'] = True
                else:
                    result['error'] = 'ÁÑ°Ê≥ïÊâæÂà∞Â∫óÂÆ∂Ë≥áË®ä'
                    
            except Exception as e:
                result['error'] = f'Ëß£ÊûêÈ†ÅÈù¢Â§±Êïó: {str(e)}'
            
            return result
            
        except Exception as e:
            return {
                'success': False,
                'platform': 'google',
                'error': f'Google Maps ÂàÜÊûêÂ§±Êïó: {str(e)}'
            }
    
    def scrape_ubereats(self, url):
        """Áà¨Âèñ UberEats Ë©ïÂÉπ"""
        try:
            if not self.driver:
                if not self.setup_driver():
                    raise Exception("WebDriver ÂàùÂßãÂåñÂ§±Êïó")
            
            print(f"üöó Ê≠£Âú®ÂàÜÊûê UberEats: {url[:50]}...")
            self.driver.get(url)
            
            # Á≠âÂæÖÈ†ÅÈù¢ÂÆåÂÖ®ËºâÂÖ•
            time.sleep(15)
            
            # ÂòóË©¶Á≠âÂæÖÈóúÈçµÂÖÉÁ¥†Âá∫Áèæ
            try:
                WebDriverWait(self.driver, 20).until(
                    lambda driver: driver.execute_script("return document.readyState") == "complete"
                )
            except:
                pass
            
            result = {
                'success': False,
                'platform': 'uber',
                'storeName': None,
                'rating': None,
                'reviewCount': None,
                'deliveryTime': None,
                'error': None
            }
            
            try:
                # Â∫óÂêç - Êõ¥Â§öÈÅ∏ÊìáÂô®
                name_selectors = [
                    'h1[data-testid="store-title"]',
                    'h1[data-testid="restaurant-name"]',
                    'h1[aria-level="1"]',
                    'h1[class*="title"]',
                    'h1[class*="name"]',
                    'h1',
                    '[data-testid="store-info-name"]',
                    '[data-testid*="name"]',
                    'div[role="heading"][aria-level="1"]'
                ]
                
                for selector in name_selectors:
                    try:
                        name_element = self.driver.find_element(By.CSS_SELECTOR, selector)
                        result['storeName'] = name_element.text.strip()
                        break
                    except:
                        continue
                
                # Ë©ïÂàÜÂíåË©ïË´ñÊï∏ - Êõ¥Â§öÈÅ∏ÊìáÂô®
                rating_selectors = [
                    '[data-testid="store-rating"]',
                    '[data-testid="rating-value"]',
                    '[data-testid*="rating"]',
                    'div[role="img"][aria-label*="Êòü"]',
                    'span[aria-label*="Êòü"]',
                    'div[role="img"][aria-label*="star"]',
                    'span[class*="rating"]',
                    'div[class*="rating"]',
                    'span[class*="star"]'
                ]
                
                for selector in rating_selectors:
                    try:
                        rating_elements = self.driver.find_elements(By.CSS_SELECTOR, selector)
                        for element in rating_elements:
                            aria_label = element.get_attribute('aria-label') or ''
                            text = element.text.strip()
                            
                            # Âæû aria-label ÊàñÊñáÊú¨‰∏≠ÊèêÂèñË©ïÂàÜ
                            rating_match = re.search(r'(\d+\.?\d*)\s*Êòü|(\d+\.?\d*)\s*ÂàÜ|(\d+\.?\d*)/5', aria_label + ' ' + text)
                            if rating_match:
                                rating = float([g for g in rating_match.groups() if g][0])
                                if 0 <= rating <= 5:
                                    result['rating'] = rating
                                    break
                        if result['rating']:
                            break
                    except:
                        continue
                
                # Ë©ïË´ñÊï∏ - Êõ¥Â§öÈÅ∏ÊìáÂô®
                review_selectors = [
                    'span[data-testid="store-reviews-count"]',
                    'span[data-testid="reviews-count"]',
                    '[data-testid*="review"]',
                    'span[aria-label*="Ë©ïË´ñ"]',
                    'span[aria-label*="review"]',
                    'div[data-testid="store-rating-and-review-count"]',
                    'span[class*="review"]',
                    'div[class*="review"]'
                ]
                
                for selector in review_selectors:
                    try:
                        review_elements = self.driver.find_elements(By.CSS_SELECTOR, selector)
                        for element in review_elements:
                            text = element.text.strip()
                            # ÂåπÈÖç "600+" ÊàñÁ¥îÊï∏Â≠ó
                            match = re.search(r'(\d+\+?)', text)
                            if match:
                                result['reviewCount'] = match.group(1)
                                break
                        if result['reviewCount']:
                            break
                    except:
                        continue
                
                # Â§ñÈÄÅÊôÇÈñì
                try:
                    time_elements = self.driver.find_elements(By.CSS_SELECTOR, '[data-testid*="delivery"], [data-testid*="time"]')
                    for element in time_elements:
                        text = element.text.strip()
                        if 'ÂàÜÈêò' in text or 'min' in text.lower():
                            result['deliveryTime'] = text
                            break
                except:
                    pass
                
                if result['storeName'] or result['rating']:
                    result['success'] = True
                else:
                    result['error'] = 'ÁÑ°Ê≥ïÊâæÂà∞Â∫óÂÆ∂Ë≥áË®ä'
                    
            except Exception as e:
                result['error'] = f'Ëß£ÊûêÈ†ÅÈù¢Â§±Êïó: {str(e)}'
            
            return result
            
        except Exception as e:
            return {
                'success': False,
                'platform': 'uber',
                'error': f'UberEats ÂàÜÊûêÂ§±Êïó: {str(e)}'
            }
    
    def scrape_foodpanda(self, url):
        """Áà¨Âèñ Foodpanda Ë©ïÂÉπ"""
        try:
            if not self.driver:
                if not self.setup_driver():
                    raise Exception("WebDriver ÂàùÂßãÂåñÂ§±Êïó")
            
            print(f"üêº Ê≠£Âú®ÂàÜÊûê Foodpanda: {url[:50]}...")
            self.driver.get(url)
            
            # Á≠âÂæÖÈ†ÅÈù¢ÂÆåÂÖ®ËºâÂÖ• (Foodpanda ÈúÄË¶ÅÊõ¥Èï∑ÊôÇÈñì)
            time.sleep(20)
            
            # ÂòóË©¶Á≠âÂæÖÈóúÈçµÂÖÉÁ¥†Âá∫Áèæ
            try:
                WebDriverWait(self.driver, 30).until(
                    lambda driver: driver.execute_script("return document.readyState") == "complete"
                )
            except:
                pass
            
            result = {
                'success': False,
                'platform': 'panda',
                'storeName': None,
                'rating': None,
                'reviewCount': None,
                'deliveryTime': None,
                'error': None
            }
            
            try:
                # Â∫óÂêç - Êõ¥Â§öÈÅ∏ÊìáÂô®
                name_selectors = [
                    'h1[data-testid="vendor-name"]',
                    'h1[data-testid="restaurant-name"]', 
                    'h1[data-testid="restaurant-title"]',
                    'h1[class*="vendor"]',
                    'h1[class*="restaurant"]',
                    'h1[class*="title"]',
                    'h1',
                    '[data-testid*="vendor"]',
                    '[data-testid*="restaurant"]',
                    'div[role="heading"][aria-level="1"]'
                ]
                
                for selector in name_selectors:
                    try:
                        name_element = self.driver.find_element(By.CSS_SELECTOR, selector)
                        result['storeName'] = name_element.text.strip()
                        break
                    except:
                        continue
                
                # Ë©ïÂàÜ - Êõ¥Â§öÈÅ∏ÊìáÂô®
                rating_selectors = [
                    '[data-testid="vendor-rating"]',
                    'span[data-testid="rating-value"]',
                    'div[data-testid="rating"]',
                    '[data-testid*="rating"]',
                    'span[class*="rating"]',
                    'div[class*="rating"]',
                    'span[class*="star"]',
                    'div[role="img"][aria-label*="star"]',
                    'span[aria-label*="star"]'
                ]
                
                for selector in rating_selectors:
                    try:
                        rating_elements = self.driver.find_elements(By.CSS_SELECTOR, selector)
                        for element in rating_elements:
                            text = element.text.strip()
                            rating_match = re.search(r'(\d+\.?\d*)', text)
                            if rating_match:
                                rating = float(rating_match.group(1))
                                if 0 <= rating <= 5:
                                    result['rating'] = rating
                                    break
                        if result['rating']:
                            break
                    except:
                        continue
                
                # Ë©ïË´ñÊï∏
                review_selectors = [
                    '[data-testid="vendor-review-count"]',
                    'span[data-testid="review-count"]',
                    'div[data-testid="reviews"]'
                ]
                
                for selector in review_selectors:
                    try:
                        review_elements = self.driver.find_elements(By.CSS_SELECTOR, selector)
                        for element in review_elements:
                            text = element.text.strip()
                            match = re.search(r'(\d+\+?)', text)
                            if match:
                                result['reviewCount'] = match.group(1)
                                break
                        if result['reviewCount']:
                            break
                    except:
                        continue
                
                if result['storeName'] or result['rating']:
                    result['success'] = True
                else:
                    result['error'] = 'ÁÑ°Ê≥ïÊâæÂà∞Â∫óÂÆ∂Ë≥áË®ä'
                    
            except Exception as e:
                result['error'] = f'Ëß£ÊûêÈ†ÅÈù¢Â§±Êïó: {str(e)}'
            
            return result
            
        except Exception as e:
            return {
                'success': False,
                'platform': 'panda',
                'error': f'Foodpanda ÂàÜÊûêÂ§±Êïó: {str(e)}'
            }

class TelegramNotifier:
    """Telegram ÈÄöÁü•Âô®"""
    
    def __init__(self):
        self.bot_token = '7659930552:AAF_jF1rAXFnjFO176-9X5fKfBwbrko8BNc'
        self.base_url = f'https://api.telegram.org/bot{self.bot_token}'
    
    def send_notification(self, results, groups):
        """ÁôºÈÄÅÈÄöÁü•Âà∞Â§öÂÄãÁæ§ÁµÑ"""
        enabled_groups = [g for g in groups if g.get('enabled') and g.get('chatId')]
        
        if not enabled_groups:
            return {'success': False, 'error': 'Ê≤íÊúâÂïüÁî®ÁöÑÁæ§ÁµÑ'}
        
        message = self.format_message(results)
        send_results = []
        
        for group in enabled_groups:
            try:
                success = self.send_message(message, group['chatId'])
                send_results.append({
                    'group': group['name'],
                    'success': success,
                    'error': None if success else 'ÁôºÈÄÅÂ§±Êïó'
                })
            except Exception as e:
                send_results.append({
                    'group': group['name'],
                    'success': False,
                    'error': str(e)
                })
        
        success_count = sum(1 for r in send_results if r['success'])
        
        return {
            'success': success_count > 0,
            'message': f'ÁôºÈÄÅÂà∞ {success_count}/{len(send_results)} ÂÄãÁæ§ÁµÑ',
            'details': send_results
        }
    
    def send_message(self, message, chat_id):
        """ÁôºÈÄÅË®äÊÅØÂà∞ÊåáÂÆöÁæ§ÁµÑ"""
        try:
            url = f"{self.base_url}/sendMessage"
            data = {
                'chat_id': chat_id,
                'text': message,
                'parse_mode': 'HTML'
            }
            
            response = requests.post(url, data=data, timeout=30)
            return response.status_code == 200 and response.json().get('ok', False)
            
        except Exception as e:
            print(f"‚ùå ÁôºÈÄÅË®äÊÅØÂ§±Êïó: {e}")
            return False
    
    def test_group(self, chat_id, group_name):
        """Ê∏¨Ë©¶Áæ§ÁµÑÈÄ£Êé•"""
        test_message = f"""üß™ Áæ§ÁµÑÈÄ£Êé•Ê∏¨Ë©¶
üì± Áæ§ÁµÑ: {group_name}
‚è∞ Ê∏¨Ë©¶ÊôÇÈñì: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
‚úÖ Â¶ÇÊûúÊÇ®Êî∂Âà∞Ê≠§Ë®äÊÅØÔºåË°®Á§∫Ê≠§Áæ§ÁµÑÈÖçÁΩÆÊ≠£Â∏∏ÔºÅ

ü§ñ Áç®Á´ãÁâàÂàÜÂ∫óË©ïÂÉπÊü•Ë©¢Á≥ªÁµ±"""
        
        try:
            success = self.send_message(test_message, chat_id)
            return {'success': success, 'group': group_name}
        except Exception as e:
            return {'success': False, 'group': group_name, 'error': str(e)}
    
    def format_message(self, results):
        """Ê†ºÂºèÂåñÈÄöÁü•Ë®äÊÅØ"""
        if not results or not results.get('stores'):
            return "‚ùå Ê≤íÊúâÂàÜÊûêÁµêÊûúÂèØÁôºÈÄÅ"
        
        store = results['stores'][0]
        time_str = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        
        message = f"""‚úàÔ∏è ÂàÜÂ∫óË©ïÂÉπÊü•Ë©¢ÁµêÊûúÈÄöÁü•
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üîç ÂàÜÂ∫ó: {store.get('name', 'Êú™Áü•')}
‚è∞ Êü•Ë©¢ÊôÇÈñì: {time_str}
üìä Âπ≥ÂùáË©ïÂàÜ: {store.get('averageRating', 0):.1f}/5.0

"""
        
        platforms = store.get('platforms', {})
        
        # Google Maps
        if platforms.get('google', {}).get('success'):
            google = platforms['google']
            message += f"""üó∫Ô∏è Google Maps
üè™ Â∫óÂêç: {google.get('storeName', 'N/A')}
‚≠ê Ë©ïÂàÜ: {google.get('rating', 'N/A')}/5.0
üí¨ Ë©ïË´ñÊï∏: {google.get('reviewCount', 'N/A')}
üìç Âú∞ÂùÄ: {google.get('address', 'N/A')}

"""
        
        # UberEats
        if platforms.get('uber', {}).get('success'):
            uber = platforms['uber']
            message += f"""üöó UberEats
üè™ Â∫óÂêç: {uber.get('storeName', 'N/A')}
‚≠ê Ë©ïÂàÜ: {uber.get('rating', 'N/A')}/5.0
üí¨ Ë©ïË´ñÊï∏: {uber.get('reviewCount', 'N/A')}
üöö Â§ñÈÄÅÊôÇÈñì: {uber.get('deliveryTime', 'N/A')}

"""
        
        # Foodpanda
        if platforms.get('panda', {}).get('success'):
            panda = platforms['panda']
            message += f"""üêº Foodpanda
üè™ Â∫óÂêç: {panda.get('storeName', 'N/A')}
‚≠ê Ë©ïÂàÜ: {panda.get('rating', 'N/A')}/5.0
üí¨ Ë©ïË´ñÊï∏: {panda.get('reviewCount', 'N/A')}
üöö Â§ñÈÄÅÊôÇÈñì: {panda.get('deliveryTime', 'N/A')}

"""
        
        message += "ü§ñ Áî±Áç®Á´ãÁâàÂàÜÂ∫óË©ïÂÉπÊü•Ë©¢Á≥ªÁµ±Ëá™ÂãïÁôºÈÄÅ"
        
        return message

class StandaloneRestaurantAnalyzer:
    """Áç®Á´ãÁâàÂàÜÂ∫óË©ïÂÉπÊü•Ë©¢Á≥ªÁµ±"""
    
    def __init__(self, root):
        self.root = root
        self.root.title("Áç®Á´ãÁâàÂàÜÂ∫óË©ïÂÉπÊü•Ë©¢Á≥ªÁµ± - ÂÆåÂÖ®Áç®Á´ãÈÅãË°å")
        self.root.geometry("900x800")
        self.root.resizable(True, True)
        
        # ÈÖçÁΩÆÊñá‰ª∂
        self.memory_file = "standalone_restaurant_memory.json"
        self.telegram_config_file = "standalone_telegram_config.json"
        
        # Ê†∏ÂøÉÁµÑ‰ª∂
        self.scraper = WebScraper()
        self.telegram_notifier = TelegramNotifier()
        self.analysis_results = None
        
        # ÂàùÂßãÂåñÁïåÈù¢
        self.setup_ui()
        
        # ËºâÂÖ•ÈÖçÁΩÆ
        self.load_memory()
        self.load_telegram_config()
        
        # Ê™¢Êü•‰æùË≥¥
        self.check_dependencies()
    
    def setup_ui(self):
        """Ë®≠ÁΩÆÁî®Êà∂ÁïåÈù¢"""
        # ÂâµÂª∫‰∏ªÊ°ÜÊû∂
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # ÈÖçÁΩÆÁ∂≤Ê†ºÊ¨äÈáç
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)
        main_frame.columnconfigure(1, weight=1)
        
        # Ê®ôÈ°å
        title_label = ttk.Label(main_frame, text="üè™ Áç®Á´ãÁâàÂàÜÂ∫óË©ïÂÉπÊü•Ë©¢Á≥ªÁµ±", 
                               font=("Arial", 16, "bold"))
        title_label.grid(row=0, column=0, columnspan=3, pady=(0, 20))
        
        # ‰æùË≥¥ÁãÄÊÖã
        status_frame = ttk.Frame(main_frame)
        status_frame.grid(row=1, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=(0, 15))
        
        ttk.Label(status_frame, text="üîß Á≥ªÁµ±ÁãÄÊÖã:").grid(row=0, column=0, sticky=tk.W)
        self.status_label = ttk.Label(status_frame, text="Ê™¢Êü•‰∏≠...", foreground="orange")
        self.status_label.grid(row=0, column=1, sticky=tk.W, padx=(10, 0))
        
        self.check_btn = ttk.Button(status_frame, text="üîÑ ÈáçÊñ∞Ê™¢Êü•", 
                                   command=self.check_dependencies, width=12)
        self.check_btn.grid(row=0, column=2, sticky=tk.E)
        status_frame.columnconfigure(1, weight=1)
        
        # ÂàÜÂ∫óË≥áË®äÊ°ÜÊû∂
        store_frame = ttk.LabelFrame(main_frame, text="üìù ÂàÜÂ∫óË≥áË®äËº∏ÂÖ•", padding="10")
        store_frame.grid(row=2, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=(0, 15))
        store_frame.columnconfigure(1, weight=1)
        
        # ÂàÜÂ∫óÂêçÁ®±
        ttk.Label(store_frame, text="üè™ ÂàÜÂ∫óÂêçÁ®±:").grid(row=0, column=0, sticky=tk.W, pady=(0, 10))
        self.store_name_var = tk.StringVar()
        self.store_name_entry = ttk.Entry(store_frame, textvariable=self.store_name_var, width=40)
        self.store_name_entry.grid(row=0, column=1, sticky=(tk.W, tk.E), pady=(0, 10), padx=(10, 0))
        
        # Google Maps Á∂≤ÂùÄ
        ttk.Label(store_frame, text="üó∫Ô∏è Google Maps:").grid(row=1, column=0, sticky=tk.W, pady=(0, 10))
        self.google_url_var = tk.StringVar()
        self.google_url_entry = ttk.Entry(store_frame, textvariable=self.google_url_var, width=40)
        self.google_url_entry.grid(row=1, column=1, sticky=(tk.W, tk.E), pady=(0, 10), padx=(10, 0))
        
        # UberEats Á∂≤ÂùÄ
        ttk.Label(store_frame, text="üöó UberEats:").grid(row=2, column=0, sticky=tk.W, pady=(0, 10))
        self.uber_url_var = tk.StringVar()
        self.uber_url_entry = ttk.Entry(store_frame, textvariable=self.uber_url_var, width=40)
        self.uber_url_entry.grid(row=2, column=1, sticky=(tk.W, tk.E), pady=(0, 10), padx=(10, 0))
        
        # Foodpanda Á∂≤ÂùÄ
        ttk.Label(store_frame, text="üêº Foodpanda:").grid(row=3, column=0, sticky=tk.W, pady=(0, 10))
        self.panda_url_var = tk.StringVar()
        self.panda_url_entry = ttk.Entry(store_frame, textvariable=self.panda_url_var, width=40)
        self.panda_url_entry.grid(row=3, column=1, sticky=(tk.W, tk.E), pady=(0, 10), padx=(10, 0))
        
        # Ë®òÊÜ∂ÂäüËÉΩÊåâÈàï
        memory_frame = ttk.Frame(main_frame)
        memory_frame.grid(row=3, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=(0, 15))
        
        ttk.Button(memory_frame, text="üíæ ‰øùÂ≠òËº∏ÂÖ•", 
                  command=self.save_memory, width=12).grid(row=0, column=0, padx=(0, 5))
        ttk.Button(memory_frame, text="üìÇ ËºâÂÖ•Ëº∏ÂÖ•", 
                  command=self.load_memory, width=12).grid(row=0, column=1, padx=5)
        ttk.Button(memory_frame, text="üßπ Ê∏ÖÁ©∫Ëº∏ÂÖ•", 
                  command=self.clear_inputs, width=12).grid(row=0, column=2, padx=(5, 0))
        
        # Telegram Áæ§ÁµÑÈÖçÁΩÆ
        self.setup_telegram_ui(main_frame, row=4)
        
        # Êìç‰ΩúÊåâÈàï
        action_frame = ttk.Frame(main_frame)
        action_frame.grid(row=5, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=(0, 15))
        
        self.analyze_btn = ttk.Button(action_frame, text="üìä ÈñãÂßãÂàÜÊûêË©ïÂÉπ", 
                                     command=self.start_analysis, width=20)
        self.analyze_btn.grid(row=0, column=0, padx=(0, 10))
        
        self.telegram_btn = ttk.Button(action_frame, text="‚úàÔ∏è ÁôºÈÄÅTelegramÈÄöÁü•", 
                                      command=self.send_telegram_notification, 
                                      width=20, state="disabled")
        self.telegram_btn.grid(row=0, column=1)
        
        # ÈÄ≤Â∫¶Ê¢ù
        self.progress_var = tk.DoubleVar()
        self.progress_bar = ttk.Progressbar(main_frame, variable=self.progress_var, 
                                           mode='determinate', length=400)
        self.progress_bar.grid(row=6, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=(0, 15))
        
        # ÁµêÊûúÈ°ØÁ§∫ÂçÄÂüü
        result_frame = ttk.LabelFrame(main_frame, text="üìä ÂàÜÊûêÁµêÊûú", padding="10")
        result_frame.grid(row=7, column=0, columnspan=3, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(0, 15))
        result_frame.columnconfigure(0, weight=1)
        result_frame.rowconfigure(0, weight=1)
        main_frame.rowconfigure(7, weight=1)
        
        self.result_text = scrolledtext.ScrolledText(result_frame, height=15, width=80, 
                                                    wrap=tk.WORD, font=("Consolas", 9))
        self.result_text.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # ÁãÄÊÖãÊ¨Ñ
        self.status_bar = ttk.Label(main_frame, text="Ê∫ñÂÇôÂ∞±Á∑í - Áç®Á´ãÈÅãË°åÊ®°Âºè", relief=tk.SUNKEN, anchor=tk.W)
        self.status_bar.grid(row=8, column=0, columnspan=3, sticky=(tk.W, tk.E))
    
    def setup_telegram_ui(self, parent, row):
        """Ë®≠ÁΩÆ Telegram Áæ§ÁµÑÈÖçÁΩÆÁïåÈù¢"""
        telegram_frame = ttk.LabelFrame(parent, text="‚úàÔ∏è Telegram Áæ§ÁµÑÈÖçÁΩÆ", padding="10")
        telegram_frame.grid(row=row, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=(0, 15))
        telegram_frame.columnconfigure(2, weight=1)
        
        # Áæ§ÁµÑÈÖçÁΩÆËÆäÊï∏
        self.telegram_groups = [
            {'name': '‰∏ªË¶ÅÁæ§ÁµÑ', 'chatId': '-1002658082392', 'enabled': True},
            {'name': 'ÂÇôÁî®Áæ§ÁµÑ1', 'chatId': '', 'enabled': False},
            {'name': 'ÂÇôÁî®Áæ§ÁµÑ2', 'chatId': '', 'enabled': False}
        ]
        
        # ÂâµÂª∫Áæ§ÁµÑÈÖçÁΩÆUI
        self.telegram_group_vars = []
        for i in range(3):
            # Áæ§ÁµÑÊ°ÜÊû∂
            group_frame = ttk.Frame(telegram_frame)
            group_frame.grid(row=i, column=0, columnspan=6, sticky=(tk.W, tk.E), pady=2)
            group_frame.columnconfigure(2, weight=1)
            
            # Áæ§ÁµÑÂêçÁ®±
            ttk.Label(group_frame, text=f"Áæ§ÁµÑ{i+1}:").grid(row=0, column=0, sticky=tk.W, padx=(0, 5))
            
            name_var = tk.StringVar(value=self.telegram_groups[i]['name'])
            name_entry = ttk.Entry(group_frame, textvariable=name_var, width=12)
            name_entry.grid(row=0, column=1, sticky=tk.W, padx=(0, 5))
            
            # Áæ§ÁµÑID
            id_var = tk.StringVar(value=self.telegram_groups[i]['chatId'])
            id_entry = ttk.Entry(group_frame, textvariable=id_var, width=25)
            id_entry.grid(row=0, column=2, sticky=(tk.W, tk.E), padx=(0, 5))
            
            # ÂïüÁî®Ê™¢Êü•Ê°Ü
            enabled_var = tk.BooleanVar(value=self.telegram_groups[i]['enabled'])
            enabled_check = ttk.Checkbutton(group_frame, text="ÂïüÁî®", variable=enabled_var)
            enabled_check.grid(row=0, column=3, sticky=tk.W, padx=(5, 5))
            
            # Ê∏¨Ë©¶ÊåâÈàï
            test_btn = ttk.Button(group_frame, text="üß™ Ê∏¨Ë©¶", width=8,
                                command=lambda idx=i: self.test_telegram_group(idx))
            test_btn.grid(row=0, column=4, sticky=tk.W, padx=(5, 0))
            
            # ‰øùÂ≠òËÆäÊï∏ÂºïÁî®
            self.telegram_group_vars.append({
                'name': name_var,
                'chatId': id_var,
                'enabled': enabled_var,
                'test_btn': test_btn
            })
        
        # Telegram ÈÖçÁΩÆÊåâÈàï
        telegram_btn_frame = ttk.Frame(telegram_frame)
        telegram_btn_frame.grid(row=3, column=0, columnspan=6, sticky=(tk.W, tk.E), pady=(10, 0))
        
        ttk.Button(telegram_btn_frame, text="üíæ ‰øùÂ≠òÁæ§ÁµÑÈÖçÁΩÆ",
                  command=self.save_telegram_config, width=15).grid(row=0, column=0, padx=(0, 5))
        ttk.Button(telegram_btn_frame, text="üìÇ ËºâÂÖ•Áæ§ÁµÑÈÖçÁΩÆ",
                  command=self.load_telegram_config, width=15).grid(row=0, column=1, padx=5)
        ttk.Button(telegram_btn_frame, text="üß™ Ê∏¨Ë©¶ÊâÄÊúâÁæ§ÁµÑ",
                  command=self.test_all_telegram_groups, width=15).grid(row=0, column=2, padx=(5, 0))
    
    def check_dependencies(self):
        """Ê™¢Êü•Á≥ªÁµ±‰æùË≥¥"""
        def check():
            try:
                # Ê™¢Êü• Selenium
                try:
                    from selenium import webdriver
                    selenium_ok = True
                except ImportError:
                    selenium_ok = False
                
                # Ê™¢Êü• Chrome Driver
                try:
                    chrome_options = Options()
                    chrome_options.add_argument('--headless')
                    chrome_options.add_argument('--no-sandbox')
                    driver = webdriver.Chrome(options=chrome_options)
                    driver.quit()
                    chrome_ok = True
                except Exception:
                    chrome_ok = False
                
                # Ê™¢Êü•Á∂≤Áµ°ÈÄ£Êé•
                try:
                    requests.get('https://www.google.com', timeout=5)
                    network_ok = True
                except:
                    network_ok = False
                
                # Êõ¥Êñ∞ÁãÄÊÖã
                if selenium_ok and chrome_ok and network_ok:
                    self.root.after(0, lambda: self.status_label.config(text="‚úÖ Á≥ªÁµ±Â∞±Á∑í", foreground="green"))
                    self.root.after(0, lambda: self.analyze_btn.config(state="normal"))
                elif not selenium_ok:
                    self.root.after(0, lambda: self.status_label.config(text="‚ùå Áº∫Â∞ë Selenium", foreground="red"))
                    self.root.after(0, lambda: self.analyze_btn.config(state="disabled"))
                elif not chrome_ok:
                    self.root.after(0, lambda: self.status_label.config(text="‚ùå Áº∫Â∞ë ChromeDriver", foreground="red"))
                    self.root.after(0, lambda: self.analyze_btn.config(state="disabled"))
                else:
                    self.root.after(0, lambda: self.status_label.config(text="‚ö†Ô∏è Á∂≤Áµ°Áï∞Â∏∏", foreground="orange"))
                    self.root.after(0, lambda: self.analyze_btn.config(state="normal"))
                
            except Exception as e:
                self.root.after(0, lambda: self.status_label.config(text="‚ùå Ê™¢Êü•Â§±Êïó", foreground="red"))
                self.root.after(0, lambda: self.analyze_btn.config(state="disabled"))
        
        threading.Thread(target=check, daemon=True).start()
    
    def start_analysis(self):
        """ÈñãÂßãÂàÜÊûêË©ïÂÉπ"""
        # È©óË≠âËº∏ÂÖ•
        if not self.store_name_var.get().strip():
            messagebox.showerror("Ëº∏ÂÖ•ÈåØË™§", "Ë´ãËº∏ÂÖ•ÂàÜÂ∫óÂêçÁ®±")
            return
        
        urls = {
            'google': self.google_url_var.get().strip(),
            'uber': self.uber_url_var.get().strip(),
            'panda': self.panda_url_var.get().strip()
        }
        
        if not any(urls.values()):
            messagebox.showerror("Ëº∏ÂÖ•ÈåØË™§", "Ëá≥Â∞ëÈúÄË¶ÅÊèê‰æõ‰∏ÄÂÄãÂπ≥Âè∞ÁöÑÁ∂≤ÂùÄ")
            return
        
        # Á¶ÅÁî®ÊåâÈàï
        self.analyze_btn.config(state="disabled")
        self.telegram_btn.config(state="disabled")
        
        # Ê∏ÖÁ©∫ÁµêÊûú
        self.result_text.delete(1.0, tk.END)
        
        # ÂïüÂãïÈÄ≤Â∫¶Ê¢ù
        self.progress_var.set(0)
        self.update_status("Ê≠£Âú®ÂàÜÊûê...")
        
        # Âú®ÂæåÂè∞Á∑öÁ®ã‰∏≠Âü∑Ë°åÂàÜÊûê
        def analyze():
            try:
                store_name = self.store_name_var.get().strip()
                
                # Ê∫ñÂÇôÁµêÊûúÁµêÊßã
                results = {
                    'summary': {
                        'totalStores': 1,
                        'averageRating': 0,
                        'totalPlatforms': 0,
                        'totalReviews': 0,
                        'analysisTime': datetime.now().isoformat()
                    },
                    'stores': [{
                        'id': 1,
                        'name': store_name,
                        'averageRating': 0,
                        'platforms': {},
                        'insights': None
                    }]
                }
                
                store = results['stores'][0]
                total_rating = 0
                valid_platforms = 0
                
                # Êõ¥Êñ∞ÈÄ≤Â∫¶
                self.root.after(0, lambda: self.progress_var.set(10))
                
                # ÂàÜÊûêÂêÑÂπ≥Âè∞
                for platform, url in urls.items():
                    if url:
                        try:
                            self.root.after(0, lambda p=platform: self.update_status(f"Ê≠£Âú®ÂàÜÊûê {p}..."))
                            
                            if platform == 'google':
                                result = self.scraper.scrape_google_maps(url)
                            elif platform == 'uber':
                                result = self.scraper.scrape_ubereats(url)
                            elif platform == 'panda':
                                result = self.scraper.scrape_foodpanda(url)
                            
                            result['url'] = url
                            store['platforms'][platform] = result
                            
                            if result.get('success') and result.get('rating'):
                                total_rating += result['rating']
                                valid_platforms += 1
                                
                                # Á¥ØÁ©çË©ïË´ñÊï∏
                                review_count = result.get('reviewCount', 0)
                                if isinstance(review_count, str):
                                    # ËôïÁêÜ "600+" Ê†ºÂºè
                                    match = re.search(r'(\d+)', review_count)
                                    if match:
                                        results['summary']['totalReviews'] += int(match.group(1))
                                elif isinstance(review_count, int):
                                    results['summary']['totalReviews'] += review_count
                            
                            # Êõ¥Êñ∞ÈÄ≤Â∫¶
                            progress = 10 + (valid_platforms * 25)
                            self.root.after(0, lambda p=progress: self.progress_var.set(p))
                            
                        except Exception as e:
                            error_result = {
                                'success': False,
                                'platform': platform,
                                'error': str(e),
                                'url': url
                            }
                            store['platforms'][platform] = error_result
                
                # Ë®àÁÆóÂπ≥ÂùáË©ïÂàÜ
                if valid_platforms > 0:
                    store['averageRating'] = total_rating / valid_platforms
                    results['summary']['averageRating'] = store['averageRating']
                    results['summary']['totalPlatforms'] = valid_platforms
                
                # ÁîüÊàêÊ¥ûÂØü
                store['insights'] = self.generate_insights(store)
                
                # ‰øùÂ≠òÁµêÊûú
                self.analysis_results = results
                
                # È°ØÁ§∫ÁµêÊûú
                self.root.after(0, self.display_results)
                self.root.after(0, lambda: self.telegram_btn.config(state="normal"))
                self.root.after(0, lambda: self.update_status("ÂàÜÊûêÂÆåÊàê"))
                
            except Exception as e:
                self.root.after(0, lambda: messagebox.showerror("ÂàÜÊûêÂ§±Êïó", f"ÂàÜÊûêÈÅéÁ®ã‰∏≠ÁôºÁîüÈåØË™§: {str(e)}"))
                self.root.after(0, lambda: self.update_status("ÂàÜÊûêÂ§±Êïó"))
            finally:
                self.root.after(0, lambda: self.progress_var.set(100))
                self.root.after(0, lambda: self.analyze_btn.config(state="normal"))
                # ÈóúÈñâÁÄèË¶ΩÂô®
                self.scraper.close_driver()
        
        threading.Thread(target=analyze, daemon=True).start()
    
    def generate_insights(self, store):
        """ÁîüÊàêÂàÜÊûêÊ¥ûÂØü"""
        platforms = store.get('platforms', {})
        valid_platforms = [p for p in platforms.values() if p.get('success')]
        
        if not valid_platforms:
            return 'ÁÑ°Ê≥ïÁç≤ÂèñË©ïÂÉπÊï∏ÊìöÔºåÂª∫Ë≠∞Ê™¢Êü•Á∂≤ÂùÄÊòØÂê¶Ê≠£Á¢∫'
        
        avg_rating = store.get('averageRating', 0)
        
        if avg_rating >= 4.5:
            return 'Ë°®ÁèæÂÑ™ÁßÄÔºÅÁπºÁ∫å‰øùÊåÅÈ´òÂìÅË≥™ÊúçÂãô'
        elif avg_rating >= 4.0:
            return 'Ë°®ÁèæËâØÂ•ΩÔºåÂèØËÄÉÊÖÆÈÄ≤‰∏ÄÊ≠•ÊèêÂçáÊúçÂãôÂìÅË≥™'
        elif avg_rating >= 3.5:
            return 'Ë°®Áèæ‰∏ÄËà¨ÔºåÂª∫Ë≠∞ÈáçÈªûÊîπÂñÑÂÆ¢Êà∂È´îÈ©ó'
        else:
            return 'ÈúÄË¶ÅÁ∑äÊÄ•ÊîπÂñÑÊúçÂãôÂìÅË≥™ÂíåÂÆ¢Êà∂ÊªøÊÑèÂ∫¶'
    
    def display_results(self):
        """È°ØÁ§∫ÂàÜÊûêÁµêÊûú"""
        if not self.analysis_results:
            return
        
        result_text = "üìä Áç®Á´ãÁâàÂàÜÂ∫óË©ïÂÉπÂàÜÊûêÁµêÊûú\n"
        result_text += "=" * 60 + "\n\n"
        
        # Á∏ΩÈ´îÁµ±Ë®à
        summary = self.analysis_results.get('summary', {})
        result_text += f"üìà Á∏ΩÈ´îÁµ±Ë®à:\n"
        result_text += f"   ÂàÜÂ∫óÊï∏Èáè: {summary.get('totalStores', 0)}\n"
        result_text += f"   Âπ≥ÂùáË©ïÂàÜ: {summary.get('averageRating', 0):.2f}/5.0\n"
        result_text += f"   ÊàêÂäüÂπ≥Âè∞: {summary.get('totalPlatforms', 0)}\n"
        result_text += f"   Á∏ΩË©ïË´ñÊï∏: {summary.get('totalReviews', 0)}\n\n"
        
        # Ë©≥Á¥∞ÁµêÊûú
        for store in self.analysis_results.get('stores', []):
            result_text += f"üè™ {store['name']}\n"
            result_text += f"üìä Â∫óÂÆ∂Âπ≥ÂùáË©ïÂàÜ: {store['averageRating']:.2f}/5.0\n"
            result_text += "-" * 50 + "\n"
            
            platforms = store.get('platforms', {})
            
            # ÂêÑÂπ≥Âè∞ÁµêÊûú
            platform_names = {'google': 'üó∫Ô∏è Google Maps', 'uber': 'üöó UberEats', 'panda': 'üêº Foodpanda'}
            
            for platform_key, platform_name in platform_names.items():
                if platform_key in platforms:
                    platform = platforms[platform_key]
                    result_text += f"{platform_name}:\n"
                    
                    if platform.get('success'):
                        result_text += f"   ‚úÖ Ë©ïÂàÜ: {platform.get('rating', 'N/A')}/5.0\n"
                        result_text += f"   üí¨ Ë©ïË´ñÊï∏: {platform.get('reviewCount', 'N/A')}\n"
                        result_text += f"   üè™ Â∫óÂêç: {platform.get('storeName', 'N/A')}\n"
                        
                        if platform.get('address'):
                            result_text += f"   üìç Âú∞ÂùÄ: {platform['address']}\n"
                        if platform.get('deliveryTime'):
                            result_text += f"   üöö Â§ñÈÄÅÊôÇÈñì: {platform['deliveryTime']}\n"
                    else:
                        result_text += f"   ‚ùå Â§±Êïó: {platform.get('error', 'Êú™Áü•ÈåØË™§')}\n"
                    
                    result_text += "\n"
            
            # ÂàÜÊûêÂª∫Ë≠∞
            if store.get('insights'):
                result_text += f"üí° ÂàÜÊûêÂª∫Ë≠∞: {store['insights']}\n"
            
            result_text += "\n"
        
        result_text += "=" * 60 + "\n"
        result_text += f"‚úÖ ÂàÜÊûêÂÆåÊàêÊôÇÈñì: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
        result_text += "ü§ñ Áî±Áç®Á´ãÁâàÂàÜÂ∫óË©ïÂÉπÊü•Ë©¢Á≥ªÁµ±Êèê‰æõ\n"
        
        # È°ØÁ§∫ÁµêÊûú
        self.result_text.delete(1.0, tk.END)
        self.result_text.insert(1.0, result_text)
    
    def send_telegram_notification(self):
        """ÁôºÈÄÅTelegramÈÄöÁü•"""
        if not self.analysis_results:
            messagebox.showerror("ÈåØË™§", "Ê≤íÊúâÂèØÁôºÈÄÅÁöÑÂàÜÊûêÁµêÊûú")
            return
        
        def send():
            try:
                self.root.after(0, lambda: self.update_status("Ê≠£Âú®ÁôºÈÄÅTelegramÈÄöÁü•..."))
                
                # Áç≤ÂèñÁæ§ÁµÑÈÖçÁΩÆ
                groups = self.get_telegram_groups()
                
                # ÁôºÈÄÅÈÄöÁü•
                result = self.telegram_notifier.send_notification(self.analysis_results, groups)
                
                if result['success']:
                    message = f"‚úÖ TelegramÈÄöÁü•ÁôºÈÄÅÊàêÂäüÔºÅ{result['message']}"
                    self.root.after(0, lambda: messagebox.showinfo("ÊàêÂäü", message))
                    self.root.after(0, lambda: self.update_status("TelegramÈÄöÁü•ÁôºÈÄÅÊàêÂäü"))
                else:
                    self.root.after(0, lambda: messagebox.showerror("ÁôºÈÄÅÂ§±Êïó", f"‚ùå {result['error']}"))
                    self.root.after(0, lambda: self.update_status("TelegramÈÄöÁü•ÁôºÈÄÅÂ§±Êïó"))
                    
            except Exception as e:
                self.root.after(0, lambda: messagebox.showerror("Á∂≤Áµ°ÈåØË™§", f"ÁôºÈÄÅÂ§±Êïó: {str(e)}"))
                self.root.after(0, lambda: self.update_status("ÁôºÈÄÅÂ§±Êïó"))
        
        threading.Thread(target=send, daemon=True).start()
    
    def save_memory(self):
        """‰øùÂ≠òËº∏ÂÖ•Ë®òÊÜ∂"""
        try:
            memory_data = {
                "store_name": self.store_name_var.get(),
                "google_url": self.google_url_var.get(),
                "uber_url": self.uber_url_var.get(),
                "panda_url": self.panda_url_var.get(),
                "saved_time": datetime.now().isoformat()
            }
            
            with open(self.memory_file, 'w', encoding='utf-8') as f:
                json.dump(memory_data, f, ensure_ascii=False, indent=2)
            
            messagebox.showinfo("‰øùÂ≠òÊàêÂäü", "üíæ Ëº∏ÂÖ•Ë®òÊÜ∂Â∑≤‰øùÂ≠ò")
            self.update_status("Ëº∏ÂÖ•Ë®òÊÜ∂Â∑≤‰øùÂ≠ò")
            
        except Exception as e:
            messagebox.showerror("‰øùÂ≠òÂ§±Êïó", f"ÁÑ°Ê≥ï‰øùÂ≠òË®òÊÜ∂: {str(e)}")
    
    def load_memory(self):
        """ËºâÂÖ•Ëº∏ÂÖ•Ë®òÊÜ∂"""
        try:
            if os.path.exists(self.memory_file):
                with open(self.memory_file, 'r', encoding='utf-8') as f:
                    memory_data = json.load(f)
                
                self.store_name_var.set(memory_data.get("store_name", ""))
                self.google_url_var.set(memory_data.get("google_url", ""))
                self.uber_url_var.set(memory_data.get("uber_url", ""))
                self.panda_url_var.set(memory_data.get("panda_url", ""))
                
                print("‚úÖ Â∑≤Ëá™ÂãïËºâÂÖ•Ëº∏ÂÖ•Ë®òÊÜ∂")
        except Exception as e:
            print(f"‚ö†Ô∏è ËºâÂÖ•Ë®òÊÜ∂Â§±Êïó: {e}")
    
    def clear_inputs(self):
        """Ê∏ÖÁ©∫ÊâÄÊúâËº∏ÂÖ•"""
        if messagebox.askyesno("Á¢∫Ë™çÊ∏ÖÁ©∫", "Á¢∫ÂÆöË¶ÅÊ∏ÖÁ©∫ÊâÄÊúâËº∏ÂÖ•ÂóéÔºü"):
            self.store_name_var.set("")
            self.google_url_var.set("")
            self.uber_url_var.set("")
            self.panda_url_var.set("")
            self.result_text.delete(1.0, tk.END)
            self.telegram_btn.config(state="disabled")
            self.analysis_results = None
            self.update_status("Â∑≤Ê∏ÖÁ©∫ÊâÄÊúâËº∏ÂÖ•")
    
    def get_telegram_groups(self):
        """Áç≤ÂèñÁï∂Ââç Telegram Áæ§ÁµÑÈÖçÁΩÆ"""
        groups = []
        for i, group_vars in enumerate(self.telegram_group_vars):
            name = group_vars['name'].get().strip()
            chat_id = group_vars['chatId'].get().strip()
            enabled = group_vars['enabled'].get()
            
            groups.append({
                'name': name or f'Áæ§ÁµÑ{i+1}',
                'chatId': chat_id,
                'enabled': enabled and chat_id != ''
            })
        
        return groups
    
    def set_telegram_groups(self, groups):
        """Ë®≠ÂÆö Telegram Áæ§ÁµÑÈÖçÁΩÆ"""
        for i, group_vars in enumerate(self.telegram_group_vars):
            if i < len(groups):
                group_vars['name'].set(groups[i].get('name', ''))
                group_vars['chatId'].set(groups[i].get('chatId', ''))
                group_vars['enabled'].set(groups[i].get('enabled', False))
            else:
                group_vars['name'].set('')
                group_vars['chatId'].set('')
                group_vars['enabled'].set(False)
    
    def save_telegram_config(self):
        """‰øùÂ≠ò Telegram Áæ§ÁµÑÈÖçÁΩÆ"""
        try:
            groups = self.get_telegram_groups()
            config_data = {
                'groups': groups,
                'timestamp': datetime.now().isoformat()
            }
            
            with open(self.telegram_config_file, 'w', encoding='utf-8') as f:
                json.dump(config_data, f, ensure_ascii=False, indent=2)
            
            messagebox.showinfo("‰øùÂ≠òÊàêÂäü", "üíæ TelegramÁæ§ÁµÑÈÖçÁΩÆÂ∑≤‰øùÂ≠ò")
            self.update_status("TelegramÁæ§ÁµÑÈÖçÁΩÆÂ∑≤‰øùÂ≠ò")
            
        except Exception as e:
            messagebox.showerror("‰øùÂ≠òÂ§±Êïó", f"ÁÑ°Ê≥ï‰øùÂ≠òTelegramÈÖçÁΩÆ: {str(e)}")
    
    def load_telegram_config(self):
        """ËºâÂÖ• Telegram Áæ§ÁµÑÈÖçÁΩÆ"""
        try:
            if os.path.exists(self.telegram_config_file):
                with open(self.telegram_config_file, 'r', encoding='utf-8') as f:
                    config_data = json.load(f)
                
                self.set_telegram_groups(config_data.get('groups', []))
                print("‚úÖ Â∑≤Ëá™ÂãïËºâÂÖ• Telegram Áæ§ÁµÑÈÖçÁΩÆ")
        except Exception as e:
            print(f"‚ö†Ô∏è ËºâÂÖ• Telegram ÈÖçÁΩÆÂ§±Êïó: {e}")
    
    def test_telegram_group(self, group_index):
        """Ê∏¨Ë©¶ÁâπÂÆöÁæ§ÁµÑÈÄ£Êé•"""
        if group_index >= len(self.telegram_group_vars):
            return
            
        group_vars = self.telegram_group_vars[group_index]
        group_name = group_vars['name'].get().strip() or f'Áæ§ÁµÑ{group_index + 1}'
        chat_id = group_vars['chatId'].get().strip()
        
        if not chat_id:
            messagebox.showerror("ÈåØË™§", "Ë´ãÂÖàËº∏ÂÖ•Áæ§ÁµÑID")
            return
        
        def test():
            try:
                self.root.after(0, lambda: self.update_status(f"Ê≠£Âú®Ê∏¨Ë©¶Áæ§ÁµÑ {group_name}..."))
                
                result = self.telegram_notifier.test_group(chat_id, group_name)
                
                if result['success']:
                    self.root.after(0, lambda: messagebox.showinfo("Ê∏¨Ë©¶ÊàêÂäü", f"‚úÖ Áæ§ÁµÑ \"{group_name}\" ÈÄ£Êé•Ê∏¨Ë©¶ÊàêÂäüÔºÅ"))
                    self.root.after(0, lambda: self.update_status(f"Áæ§ÁµÑ {group_name} Ê∏¨Ë©¶ÊàêÂäü"))
                else:
                    error_msg = result.get('error', 'Êú™Áü•ÈåØË™§')
                    self.root.after(0, lambda: messagebox.showerror("Ê∏¨Ë©¶Â§±Êïó", f"‚ùå Áæ§ÁµÑ \"{group_name}\" Ê∏¨Ë©¶Â§±Êïó: {error_msg}"))
                    self.root.after(0, lambda: self.update_status(f"Áæ§ÁµÑ {group_name} Ê∏¨Ë©¶Â§±Êïó"))
                    
            except Exception as e:
                self.root.after(0, lambda: messagebox.showerror("Á∂≤Áµ°ÈåØË™§", f"Ê∏¨Ë©¶Â§±Êïó: {str(e)}"))
                self.root.after(0, lambda: self.update_status("Áæ§ÁµÑÊ∏¨Ë©¶Â§±Êïó"))
        
        threading.Thread(target=test, daemon=True).start()
    
    def test_all_telegram_groups(self):
        """Ê∏¨Ë©¶ÊâÄÊúâÂïüÁî®ÁöÑÁæ§ÁµÑ"""
        groups = self.get_telegram_groups()
        enabled_groups = [g for g in groups if g['enabled'] and g['chatId']]
        
        if not enabled_groups:
            messagebox.showwarning("Ë≠¶Âëä", "Ê≤íÊúâÂïüÁî®ÁöÑÁæ§ÁµÑÂèØ‰ª•Ê∏¨Ë©¶")
            return
        
        def test_all():
            try:
                self.root.after(0, lambda: self.update_status(f"Ê≠£Âú®Ê∏¨Ë©¶ {len(enabled_groups)} ÂÄãÁæ§ÁµÑ..."))
                
                results = []
                for group in enabled_groups:
                    result = self.telegram_notifier.test_group(group['chatId'], group['name'])
                    results.append(result)
                
                success_count = sum(1 for r in results if r['success'])
                message = f"üìä Ê∏¨Ë©¶ÂÆåÊàê: {success_count}/{len(results)} ÂÄãÁæ§ÁµÑÈÄ£Êé•ÊàêÂäü"
                
                if success_count == len(results):
                    self.root.after(0, lambda: messagebox.showinfo("Ê∏¨Ë©¶ÂÆåÊàê", f"‚úÖ {message}"))
                else:
                    failed_groups = [r['group'] for r in results if not r['success']]
                    detail_msg = f"{message}\n\nÂ§±ÊïóÁöÑÁæ§ÁµÑ: {', '.join(failed_groups)}"
                    self.root.after(0, lambda: messagebox.showwarning("Ê∏¨Ë©¶ÂÆåÊàê", f"‚ö†Ô∏è {detail_msg}"))
                
                self.root.after(0, lambda: self.update_status(message))
                
            except Exception as e:
                self.root.after(0, lambda: messagebox.showerror("ÈåØË™§", f"Ê∏¨Ë©¶ÈÅéÁ®ã‰∏≠ÁôºÁîüÈåØË™§: {str(e)}"))
                self.root.after(0, lambda: self.update_status("Áæ§ÁµÑÊ∏¨Ë©¶Â§±Êïó"))
        
        threading.Thread(target=test_all, daemon=True).start()
    
    def update_status(self, message):
        """Êõ¥Êñ∞ÁãÄÊÖãÊ¨Ñ"""
        timestamp = datetime.now().strftime('%H:%M:%S')
        self.status_bar.config(text=f"[{timestamp}] {message}")

def install_requirements():
    """ÂÆâË£ùÂøÖË¶ÅÁöÑ‰æùË≥¥"""
    required_packages = ['selenium', 'requests']
    
    for package in required_packages:
        try:
            __import__(package)
            print(f"‚úÖ {package} Â∑≤ÂÆâË£ù")
        except ImportError:
            print(f"‚ö†Ô∏è Ê≠£Âú®ÂÆâË£ù {package}...")
            try:
                subprocess.check_call([sys.executable, "-m", "pip", "install", package])
                print(f"‚úÖ {package} ÂÆâË£ùÊàêÂäü")
            except subprocess.CalledProcessError:
                print(f"‚ùå {package} ÂÆâË£ùÂ§±Êïó")
                return False
    
    return True

def main():
    """‰∏ªÂáΩÊï∏"""
    print("üöÄ Áç®Á´ãÁâàÂàÜÂ∫óË©ïÂÉπÊü•Ë©¢Á≥ªÁµ±ÂïüÂãï")
    print("=" * 50)
    
    # Ê™¢Êü•‰∏¶ÂÆâË£ù‰æùË≥¥
    if not install_requirements():
        print("‚ùå ‰æùË≥¥ÂÆâË£ùÂ§±ÊïóÔºåÁ®ãÂºèÁÑ°Ê≥ïÁπºÁ∫åÂü∑Ë°å")
        input("Êåâ Enter ÈçµÈÄÄÂá∫...")
        return
    
    # ÂâµÂª∫‰∏ªË¶ñÁ™ó
    root = tk.Tk()
    
    # Ë®≠ÁΩÆ‰∏ªÈ°å
    try:
        style = ttk.Style()
        style.theme_use('clam')
    except:
        pass
    
    # ÂâµÂª∫ÊáâÁî®
    app = StandaloneRestaurantAnalyzer(root)
    
    # ËôïÁêÜË¶ñÁ™óÈóúÈñâ‰∫ã‰ª∂
    def on_closing():
        if messagebox.askokcancel("ÈÄÄÂá∫", "Á¢∫ÂÆöË¶ÅÈóúÈñâÁç®Á´ãÁâàÂàÜÂ∫óË©ïÂÉπÊü•Ë©¢Á≥ªÁµ±ÂóéÔºü"):
            # ÈóúÈñâÁÄèË¶ΩÂô®
            app.scraper.close_driver()
            root.destroy()
    
    root.protocol("WM_DELETE_WINDOW", on_closing)
    
    print("‚úÖ GUI ÁïåÈù¢Â∑≤ÂïüÂãï")
    print("üìù Ê≥®ÊÑè‰∫ãÈ†ÖÔºö")
    print("   - ÈúÄË¶ÅÂÆâË£ù Chrome ÁÄèË¶ΩÂô®Âíå ChromeDriver")
    print("   - È¶ñÊ¨°‰ΩøÁî®ÊúÉËá™Âãï‰∏ãËºâ ChromeDriver")
    print("   - ÂÆåÂÖ®Áç®Á´ãÈÅãË°åÔºå‰∏ç‰æùË≥¥ Node.js ÂæåÁ´Ø")
    
    # ÂïüÂãïÊáâÁî®
    root.mainloop()

if __name__ == "__main__":
    main()